#include <Adafruit_SSD1306.h>
#include <U8g2lib.h>
#include <Wire.h>
#include "menu.h"
#include "pages/page_info.h"
#include "pages/page_basic_data.h"
#include "pages/page_oil_temp.h"
#include "pages/page_rpm.h"

Adafruit_SSD1306 display(128, 64, &Wire, 4);
U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);

static const unsigned char image_AD_bits[] = {0x04,0x04,0x04,0x04,0x15,0x0e,0x04};
static const unsigned char image_AU_bits[] = {0x04,0x0e,0x15,0x04,0x04,0x04,0x04};
static const unsigned char image_BASIC_DATA_bits[] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x3f,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x31,0x00,0x02,0x40,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x9b,0x21,0x51,0x66,0x60,0x60,0x76,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x21,0x31,0x35,0x13,0x50,0x25,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x21,0x51,0x45,0x12,0x50,0x25,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x21,0x31,0x36,0x67,0x60,0x46,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x9b,0x21,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x3f};
static const unsigned char image_INFO_bits[] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x3f,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x71,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x93,0x21,0x21,0x23,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x21,0x21,0x75,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x19,0x21,0x21,0x25,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x11,0x21,0x71,0x25,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xbb,0x21,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x3f};
static const unsigned char image_OIL_TEMP_bits[] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x3f,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x21,0x32,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x93,0x21,0x51,0x20,0x70,0x52,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x21,0x51,0x23,0x20,0x75,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x21,0x51,0x22,0x20,0x53,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x21,0x21,0x77,0x40,0x56,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x93,0x21,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x3f};
static const unsigned char image_RPM_bits[] = {0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x3f,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x31,0x53,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x9b,0x21,0x51,0x75,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x21,0x31,0x73,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x19,0x21,0x51,0x51,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x21,0x51,0x51,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xab,0x21,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x3f};
static const unsigned char image_CHECK_bits[] = {0x00,0x00,0x20,0x31,0x1b,0x0e,0x04,0x00};

const unsigned char* bitmap_btn_codes[4] = {
  image_INFO_bits,
  image_BASIC_DATA_bits,
  image_OIL_TEMP_bits,
  image_RPM_bits
};

const int NUM_ITEMS = 4;

// Button pins
const int BUTTON_UP = 18;    // Previous item (UP)
const int BUTTON_DOWN = 19;  // Next item (DOWN)
const int BUTTON_SELECT = 5; // Select current item

// Button state variables
bool button_up_pressed = false;
bool button_down_pressed = false;
bool button_select_pressed = false;
unsigned long last_button_time = 0;
const unsigned long DEBOUNCE_DELAY = 200; // 200ms debounce

// Global flag to prevent immediate button trigger when entering a page
bool just_entered_page = false;
unsigned long page_enter_time = 0;

// Menu item names for debug
const char* menu_names[4] = {
  "info",
  "basic data", 
  "oil temp",
  "rpm"
};

// Add state management
AppState current_state = STATE_MENU;

int item_selected = 0;
int prev_item;
int next_item;

void setup() {
  Serial.begin(115200);
  
  u8g2.begin();
  u8g2.setColorIndex(1);
  
  // Setup button pins with internal pull-up resistors
  pinMode(BUTTON_UP, INPUT_PULLUP);
  pinMode(BUTTON_DOWN, INPUT_PULLUP);
  pinMode(BUTTON_SELECT, INPUT_PULLUP);
  
  Serial.println("Menu System Ready!");
  Serial.println("Button UP: GPIO18, Button DOWN: GPIO19, Button SELECT: GPIO5");
}

// Move menu drawing to separate function
void drawMenu() {
  // Calculate prev and next items with proper 0-based indexing
  int prev_item = (item_selected - 1 + NUM_ITEMS) % NUM_ITEMS;
  int next_item = (item_selected + 1) % NUM_ITEMS;
  
  // Draw background
  u8g2.clearBuffer();
  u8g2.setFontMode(1);
  u8g2.setBitmapMode(1);
  
  // Title
  u8g2.setFont(u8g2_font_4x6_tr);
  u8g2.drawStr(5, 9, "Menu");

  // Navigation arrows
  u8g2.drawXBM(119, 12, 5, 7, image_AU_bits);
  u8g2.drawXBM(119, 52, 5, 7, image_AD_bits);

  // Draw checkmark
  u8g2.drawXBM(92, 31, 6, 8, image_CHECK_bits);

  // Draw menu items
  u8g2.drawXBM(5, 12, 110, 13, bitmap_btn_codes[prev_item]);
  u8g2.drawXBM(5, 29, 110, 13, bitmap_btn_codes[item_selected]);
  u8g2.drawXBM(5, 46, 110, 13, bitmap_btn_codes[next_item]);

  u8g2.sendBuffer();
}

// Update handleButtons to change state on SELECT
void handleMenuButtons() {
  unsigned long current_time = millis();
  
  if (current_time - last_button_time > DEBOUNCE_DELAY) {
    
    // Check UP button (Previous item)
    if (digitalRead(BUTTON_UP) == LOW && !button_up_pressed) {
      button_up_pressed = true;
      item_selected = (item_selected - 1 + NUM_ITEMS) % NUM_ITEMS;
      last_button_time = current_time;
      Serial.print("UP pressed - Item selected: ");
      Serial.println(item_selected);
    }
    else if (digitalRead(BUTTON_UP) == HIGH) {
      button_up_pressed = false;
    }
    
    // Check DOWN button (Next item)
    if (digitalRead(BUTTON_DOWN) == LOW && !button_down_pressed) {
      button_down_pressed = true;
      item_selected = (item_selected + 1) % NUM_ITEMS;
      last_button_time = current_time;
      Serial.print("DOWN pressed - Item selected: ");
      Serial.println(item_selected);
    }
    else if (digitalRead(BUTTON_DOWN) == HIGH) {
      button_down_pressed = false;
    }
    
    // Check SELECT button - Navigate to selected page
    if (digitalRead(BUTTON_SELECT) == LOW && !button_select_pressed) {
      button_select_pressed = true;
      last_button_time = current_time;
      
      // Switch to the selected page
      switch(item_selected) {
        case 0: current_state = STATE_PAGE_INFO; break;
        case 1: current_state = STATE_PAGE_BASIC_DATA; break;
        case 2: current_state = STATE_PAGE_OIL_TEMP; break;
        case 3: current_state = STATE_PAGE_RPM; break;
      }
      
      // Set flag to prevent immediate button trigger in pages
      just_entered_page = true;
      page_enter_time = current_time;
      
      Serial.print("SELECT pressed - Entering page: ");
      Serial.println(menu_names[item_selected]);
    }
    else if (digitalRead(BUTTON_SELECT) == HIGH) {
      button_select_pressed = false;
    }
  }
}

void loop() {
  // State machine
  switch(current_state) {
    case STATE_MENU:
      handleMenuButtons();
      drawMenu();
      break;
      
    case STATE_PAGE_INFO:
      handlePageInfo();
      drawPageInfo();
      break;
      
    case STATE_PAGE_BASIC_DATA:
      handlePageBasicData();
      drawPageBasicData();
      break;
      
    case STATE_PAGE_OIL_TEMP:
      handlePageOilTemp();
      drawPageOilTemp();
      break;
      
    case STATE_PAGE_RPM:
      handlePageRpm();
      drawPageRpm();
      break;
  }
  
  // Small delay to prevent excessive CPU usage
  delay(50);
}